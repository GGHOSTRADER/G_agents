----- AGENTIC WORK OPTIMIZATION -----

Software developing
--------------------
Goal: Balance between Autonomy while keeping clarity and maintainability.

-Prompting
As a efficient python developer and clean architecture software engineer

-Code Generating for reability and maintainability: 
1) Ask for heavy documentation inside file on each function and doc string summary
2) PURE FUNCTIONS: Ask agent to create pure functions, one function per action, so avoid nested functions, always have doc string describing the function in 8 words and telling what is the input and output. Use variables linting (check proper name). Also ask to avoi calling functions inside functions.
3) Generate "dry" summary, Functions names, description of function in 1 sentence, necessary inputs with data type and what output with what datatype, state if it has side effects.
4) High level summary and goal of the whole script
5) Runtime Chain ( To see the actual flow of the application)
6) Function Dependency Graph ( To understand what depends on what but if pure functions this should be limited)
7) Use of type hints for functions


-Contex for LLM
1) Give Tree structure to LLM, use Tree in Linux
2) Give imports with clear relative paths, be expecific that they are already made
3) Give breef summary of imported functions, with input and output data types and what they do in 1 sentence, so LLM wont put extra arguments



-Bug Handling
1) Ask: give solution to this problem, with why you choose this way, what did you change
2) Be expecific about what lines it can change and what it CANNOT change or touch
3) Color/Label code changes on code and on 5 words why it was done + Date (line number of changes)

-Testing and Architectural design
1) Feeds from failure mode and invariants (Invariant is what is valid, failure mode is what breaks it on real life)
2) TDD Implementation, Human user gives tests to pass and let agent develop the solution to pass the test.

-Offline solutions
7) LOCAL LLM for coding offline, probably no solution generating.
	Provide clear relative path in instructions with


EXAMPLE CONTRACT

structure
Name (BOILER PLATE)
----
Input : names of variables or objects and how many
Input data type: the type of them
Input Origin: Points if its generated in this file or in another
Output : what the output is
Output Data Type: the type of the output
Style: Pure Function , Clean architecture
Description : Describe in high level what is happening
Calculation : computer readable instructions to calculate
invariants : Things that should always remain true.
Failure Mode: What can invalidate the invariants, explanations.
Acceptance criteria: Basically the high level defining of tests
Assumptions / Guarantees : Things that are pre checked and done before  by another layer/process but are crucial

Invarianat presents the truth to look for
Failure Mode presents how the truth can be violated
Acceptance Criteria presents how we test to see if


Clean Architectural
Domain: “I compute features”
Application: “I decide when to compute”
Adapter: “I fetch/emit data”




modSlope5
----
Input :  5 bar window Object called b, b class that contains the attributes .low , .high .close , .bar_num
Input data type: Float
Input Origin: comes from global process
Output : Float
Output Data Type:
Style: Pure Function , Clean architecture
Description : Slope of the last 5 bars
Calculation : (high[-1] + low[-1] + close[-1])/3 - (high[-5] + low[-5] + close[-5])/3
invariants : 
	bar value = math.isfinite(modSlope5) # To cover Nan and inf
	end points difference = bar_num[-1] - bar_num[-5] == 4,  
	Buffer = len("buffer name") => 5 , 
	Bar continuinity = all(bar_nums[i] == bar_nums[i-1] + 1 for i in range(1, 5))
Failure Mode: Low Xor high Xor close == NAN
Acceptance criteria:




----------------------------------------------------------------------------------- 